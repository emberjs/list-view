minispade.register('list-view/list_item_view', "(function() {minispade.require('list-view/list_item_view_mixin');\n\nvar get = Ember.get, set = Ember.set;\n\nvar backportedInnerString = function(buffer) {\n  var content = [], childBuffers = buffer.childBuffers;\n\n  Ember.ArrayPolyfills.forEach.call(childBuffers, function(buffer) {\n    var stringy = typeof buffer === 'string';\n    if (stringy) {\n      content.push(buffer);\n    } else {\n      buffer.array(content);\n    }\n  });\n\n  return content.join('');\n};\n\nfunction willInsertElementIfNeeded(view) {\n  if (view.willInsertElement) {\n    view.willInsertElement();\n  }\n}\n\nfunction didInsertElementIfNeeded(view) {\n  if (view.didInsertElement) {\n    view.didInsertElement();\n  }\n}\n\nfunction rerender() {\n  var element, buffer, context, hasChildViews;\n  element = get(this, 'element');\n\n  if (!element) { return; }\n\n  context = get(this, 'context');\n\n  // releases action helpers in contents\n  // this means though that the ListViewItem itself can't use classBindings or attributeBindings\n  // need support for rerender contents in ember\n  this.triggerRecursively('willClearRender');\n\n  if (this.lengthAfterRender > this.lengthBeforeRender) {\n    this.clearRenderedChildren();\n    this._childViews.length = this.lengthBeforeRender; // triage bug in ember\n  }\n\n  if (context) {\n    buffer = Ember.RenderBuffer();\n    buffer = this.renderToBuffer(buffer);\n\n    // check again for childViews, since rendering may have added some\n    hasChildViews = this._childViews.length > 0;\n\n    if (hasChildViews) {\n      this.invokeRecursively(willInsertElementIfNeeded, false);\n    }\n\n    element.innerHTML = buffer.innerString ? buffer.innerString() : backportedInnerString(buffer);\n\n    set(this, 'element', element);\n\n    this.transitionTo('inDOM');\n\n    if (hasChildViews) {\n      this.invokeRecursively(didInsertElementIfNeeded, false);\n    }\n  } else {\n    element.innerHTML = ''; // when there is no context, this view should be completely empty\n  }\n}\n\n/**\n  The `Ember.ListViewItem` view class renders a\n  [div](https://developer.mozilla.org/en/HTML/Element/div) HTML element\n  with `ember-list-item-view` class. It allows you to specify a custom item\n  handlebars template for `Ember.ListView`.\n\n  Example:\n\n  ```handlebars\n  <script type=\"text/x-handlebars\" data-template-name=\"row_item\">\n    {{name}}\n  </script>\n  ```\n\n  ```javascript\n  App.ListView = Ember.ListView.extend({\n    height: 500,\n    rowHeight: 20,\n    itemViewClass: Ember.ListItemView.extend({templateName: \"row_item\"})\n  });\n  ```\n\n  @extends Ember.View\n  @class ListItemView\n  @namespace Ember\n*/\nEmber.ListItemView = Ember.View.extend(Ember.ListItemViewMixin, {\n  updateContext: function(newContext){\n    var context = get(this, 'context');\n    Ember.instrument('view.updateContext.render', this, function() {\n      if (context !== newContext) {\n        this.set('context', newContext);\n        if (newContext instanceof Ember.ObjectController) {\n          this.set('controller', newContext);\n        }\n      }\n    }, this);\n  },\n  rerender: function () { Ember.run.scheduleOnce('render', this, rerender); },\n  _contextDidChange: Ember.observer(rerender, 'context', 'controller')\n});\n\n})();\n//@ sourceURL=list-view/list_item_view");minispade.register('list-view/list_item_view_mixin', "(function() {var get = Ember.get, set = Ember.set;\n\nfunction samePosition(a, b) {\n  return a && b && a.x === b.x && a.y === b.y;\n}\n\nfunction positionElement() {\n  var element, position, _position;\n\n  Ember.instrument('view.updateContext.positionElement', this, function() {\n    element = get(this, 'element');\n    position = get(this, 'position');\n    _position = this._position;\n\n    if (!position || !element) { return; }\n\n    // TODO: avoid needing this by avoiding unnecessary\n    // calls to this method in the first place\n    if (samePosition(position, _position)) { return; }\n    this._parentView.applyTransform(element, position.x, position.y);\n\n    this._position = position;\n  }, this);\n}\n\nEmber.ListItemViewMixin = Ember.Mixin.create({\n  init: function(){\n    this._super();\n    this.one('didInsertElement', positionElement);\n  },\n  classNames: ['ember-list-item-view'],\n  _position: null,\n  _positionDidChange: Ember.observer(positionElement, 'position'),\n  _positionElement: positionElement\n});\n\n})();\n//@ sourceURL=list-view/list_item_view_mixin");minispade.register('list-view/list_view', "(function() {minispade.require('list-view/list_view_mixin');\nminispade.require('list-view/list_view_helper');\n\nvar get = Ember.get, set = Ember.set;\n\n/**\n  The `Ember.ListView` view class renders a\n  [div](https://developer.mozilla.org/en/HTML/Element/div) HTML element,\n  with `ember-list-view` class.\n\n  The context of each item element within the `Ember.ListView` are populated\n  from the objects in the `Element.ListView`'s `content` property.\n\n  ### `content` as an Array of Objects\n\n  The simplest version of an `Ember.ListView` takes an array of object as its\n  `content` property. The object will be used as the `context` each item element\n  inside the rendered `div`.\n\n  Example:\n\n  ```javascript\n  App.contributors = [{ name: 'Stefan Penner' }, { name: 'Alex Navasardyan' }, { name: 'Rey Cohen'}];\n  ```\n\n  ```handlebars\n  {{#collection Ember.ListView contentBinding=\"App.contributors\" height=500 rowHeight=50}}\n    {{name}}\n  {{/collection}}\n  ```\n\n  Would result in the following HTML:\n\n  ```html\n   <div id=\"ember181\" class=\"ember-view ember-list-view\" style=\"height:500px;width:500px;position:relative;overflow:scroll;-webkit-overflow-scrolling:touch;overflow-scrolling:touch;\">\n    <div class=\"ember-list-container\">\n      <div id=\"ember186\" class=\"ember-view ember-list-item-view\" style=\"-webkit-transform: translate3d(0px, 0px, 0);\">\n        <script id=\"metamorph-0-start\" type=\"text/x-placeholder\"></script>Stefan Penner<script id=\"metamorph-0-end\" type=\"text/x-placeholder\"></script>\n      </div>\n      <div id=\"ember187\" class=\"ember-view ember-list-item-view\" style=\"-webkit-transform: translate3d(0px, 50px, 0);\">\n        <script id=\"metamorph-1-start\" type=\"text/x-placeholder\"></script>Alex Navasardyan<script id=\"metamorph-1-end\" type=\"text/x-placeholder\"></script>\n      </div>\n      <div id=\"ember188\" class=\"ember-view ember-list-item-view\" style=\"-webkit-transform: translate3d(0px, 100px, 0);\">\n        <script id=\"metamorph-2-start\" type=\"text/x-placeholder\"></script>Rey Cohen<script id=\"metamorph-2-end\" type=\"text/x-placeholder\"></script>\n      </div>\n      <div id=\"ember189\" class=\"ember-view ember-list-scrolling-view\" style=\"height: 150px\"></div>\n    </div>\n  </div>\n  ```\n\n  By default `Ember.ListView` provides support for `height`,\n  `rowHeight`, `width`, `elementWidth`, `scrollTop` parameters.\n\n  Note, that `height` and `rowHeight` are required parameters.\n\n  ```handlebars\n  {{#collection Ember.ListView contentBinding=\"App.contributors\" height=500 rowHeight=50}}\n    {{name}}\n  {{/collection}}\n  ```\n\n  If you would like to have multiple columns in your view layout, you can\n  set `width` and `elementWidth` parameters respectively.\n\n  ```handlebars\n  {{#collection Ember.ListView contentBinding=\"App.contributors\" height=500 rowHeight=50 width=500 elementWidth=80}}\n    {{name}}\n  {{/collection}}\n  ```\n\n  ### extending `Ember.ListView`\n\n  Example:\n\n  ```handlebars\n  {{view App.ListView contentBinding=\"content\"}}\n\n  <script type=\"text/x-handlebars\" data-template-name=\"row_item\">\n    {{name}}\n  </script>\n  ```\n\n  ```javascript\n  App.ListView = Ember.ListView.extend({\n    height: 500,\n    width: 500,\n    elementWidth: 80,\n    rowHeight: 20,\n    itemViewClass: Ember.ListItemView.extend({templateName: \"row_item\"})\n  });\n  ```\n\n  @extends Ember.ContainerView\n  @class ListView\n  @namespace Ember\n*/\nEmber.ListView = Ember.ContainerView.extend(Ember.ListViewMixin, {\n  css: {\n    position: 'relative',\n    overflow: 'scroll',\n    '-webkit-overflow-scrolling': 'touch',\n    'overflow-scrolling': 'touch'\n  },\n\n  applyTransform: Ember.ListViewHelper.applyTransform,\n\n  _scrollTo: function(scrollTop) {\n    var element = get(this, 'element');\n\n    if (element) { element.scrollTop = scrollTop; }\n  },\n\n  didInsertElement: function() {\n    var that, element;\n\n    that = this,\n    element = get(this, 'element');\n\n    this._updateScrollableHeight();\n\n    this._scroll = function(e) { that.scroll(e); };\n\n    Ember.$(element).on('scroll', this._scroll);\n  },\n\n  willDestroyElement: function() {\n    var element;\n\n    element = get(this, 'element');\n\n    Ember.$(element).off('scroll', this._scroll);\n  },\n\n  scroll: function(e) {\n    Ember.run(this, this.scrollTo, e.target.scrollTop);\n  },\n\n  scrollTo: function(y){\n    var element = get(this, 'element');\n    this._scrollTo(y);\n    this._scrollContentTo(y);\n  },\n\n  totalHeightDidChange: Ember.observer(function () {\n    Ember.run.scheduleOnce('afterRender', this, this._updateScrollableHeight);\n  }, 'totalHeight'),\n\n  _updateScrollableHeight: function () {\n    if (this.state === 'inDOM') {\n      this.$('.ember-list-container').css({\n        height: get(this, 'totalHeight')\n      });\n    }\n  }\n});\n\n})();\n//@ sourceURL=list-view/list_view");minispade.register('list-view/list_view_helper', "(function() {var el = document.createElement('div'), style = el.style;\n\nvar propPrefixes = ['Webkit', 'Moz', 'O', 'ms'];\n\nfunction testProp(prop) {\n  if (prop in style) return prop;\n  var uppercaseProp = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i=0; i<propPrefixes.length; i++) {\n    var prefixedProp = propPrefixes[i] + uppercaseProp;\n    if (prefixedProp in style) {\n      return prefixedProp;\n    }\n  }\n  return null;\n}\n\nvar transformProp = testProp('transform');\nvar perspectiveProp = testProp('perspective');\n\nvar supports2D = transformProp !== null;\nvar supports3D = perspectiveProp !== null;\n\nEmber.ListViewHelper = {\n  transformProp: transformProp,\n  applyTransform: (function(){\n    if (supports2D) {\n      return function(element, x, y){\n        element.style[transformProp] = 'translate(' + x + 'px, ' + y + 'px)';\n      };\n    } else {\n      return function(element, x, y){\n        element.style.top  = y + 'px';\n        element.style.left = x + 'px';\n      };\n    }\n  })(),\n  apply3DTransform: (function(){\n    if (supports3D) {\n      return function(element, x, y){\n        element.style[transformProp] = 'translate3d(' + x + 'px, ' + y + 'px, 0)';\n      };\n    } else if (supports2D) {\n      return function(element, x, y){\n        element.style[transformProp] = 'translate(' + x + 'px, ' + y + 'px)';\n      };\n    } else {\n      return function(element, x, y){\n        element.style.top  = y + 'px';\n        element.style.left = x + 'px';\n      };\n    }\n  })()\n};\n\n})();\n//@ sourceURL=list-view/list_view_helper");minispade.register('list-view/list_view_mixin', "(function() {minispade.require('list-view/list_view_helper');\n\nvar get = Ember.get, set = Ember.set,\nmin = Math.min, max = Math.max, floor = Math.floor,\nceil = Math.ceil,\nforEach = Ember.ArrayPolyfills.forEach;\n\nfunction addContentArrayObserver() {\n  var content = get(this, 'content');\n  if (content) {\n    content.addArrayObserver(this);\n  }\n}\n\nfunction removeAndDestroy(object){\n  this.removeObject(object);\n  object.destroy();\n}\n\nfunction syncChildViews(){\n  Ember.run.once(this, '_syncChildViews');\n}\n\nfunction sortByContentIndex (viewOne, viewTwo){\n  return get(viewOne, 'contentIndex') - get(viewTwo, 'contentIndex');\n}\n\nfunction notifyMutationListeners() {\n  if (Ember.View.notifyMutationListeners) {\n    Ember.run.once(Ember.View, 'notifyMutationListeners');\n  }\n}\n\nvar domManager = Ember.create(Ember.ContainerView.proto().domManager);\n\ndomManager.prepend = function(view, html) {\n  view.$('.ember-list-container').prepend(html);\n  notifyMutationListeners();\n};\n\nfunction syncListContainerWidth(){\n  var elementWidth, columnCount, containerWidth, element;\n\n  elementWidth = get(this, 'elementWidth');\n  columnCount = get(this, 'columnCount');\n  containerWidth = elementWidth * columnCount;\n  element = this.$('.ember-list-container');\n\n  if (containerWidth && element) {\n    element.css('width', containerWidth);\n  }\n}\n\nfunction enableProfilingOutput() {\n  function before(name, time, payload) {\n    console.time(name);\n  }\n\n  function after (name, time, payload) {\n    console.timeEnd(name);\n  }\n\n  if (Ember.ENABLE_PROFILING) {\n    Ember.subscribe('view._scrollContentTo', {\n      before: before,\n      after: after\n    });\n    Ember.subscribe('view.updateContext', {\n      before: before,\n      after: after\n    });\n  }\n}\n\n/**\n  @class Ember.ListViewMixin\n  @namespace Ember\n*/\nEmber.ListViewMixin = Ember.Mixin.create({\n  itemViewClass: Ember.ListItemView,\n  emptyViewClass: Ember.View,\n  classNames: ['ember-list-view'],\n  attributeBindings: ['style'],\n  domManager: domManager,\n  scrollTop: 0,\n  bottomPadding: 0,\n  _lastEndingIndex: 0,\n  paddingCount: 1,\n\n  /**\n    @private\n\n    Setup a mixin.\n    - adding observer to content array\n    - creating child views based on height and length of the content array\n\n    @method init\n  */\n  init: function() {\n    this._super();\n    this.on('didInsertElement', syncListContainerWidth);\n    this.columnCountDidChange();\n    this._syncChildViews();\n    this._addContentArrayObserver();\n  },\n\n  _addContentArrayObserver: Ember.beforeObserver(function() {\n    addContentArrayObserver.call(this);\n  }, 'content'),\n\n  /**\n    Called on your view when it should push strings of HTML into a\n    `Ember.RenderBuffer`.\n\n    Adds a [div](https://developer.mozilla.org/en-US/docs/HTML/Element/div)\n    with a required `ember-list-container` class.\n\n    @method render\n    @param {Ember.RenderBuffer} buffer The render buffer\n  */\n  render: function(buffer) {\n    buffer.push('<div class=\"ember-list-container\">');\n    this._super(buffer);\n    buffer.push('</div>');\n  },\n\n  willInsertElement: function() {\n    if (!this.get(\"height\") || !this.get(\"rowHeight\")) {\n      throw new Error(\"A ListView must be created with a height and a rowHeight.\");\n    }\n    this._super();\n  },\n\n  /**\n    @private\n\n    Sets inline styles of the view:\n    - height\n    - width\n    - position\n    - overflow\n    - -webkit-overflow\n    - overflow-scrolling\n\n    Called while attributes binding.\n\n    @property {Ember.ComputedProperty} style\n  */\n  style: Ember.computed('height', 'width', function() {\n    var height, width, style, css;\n\n    height = get(this, 'height');\n    width = get(this, 'width');\n    css = get(this, 'css');\n\n    style = '';\n\n    if (height) { style += 'height:' + height + 'px;'; }\n    if (width)  { style += 'width:'  + width  + 'px;'; }\n\n    for ( var rule in css ){\n      if (css.hasOwnProperty(rule)) {\n        style += rule + ':' + css[rule] + ';';\n      }\n    }\n\n    return style;\n  }),\n\n  /**\n    @private\n\n    Performs visual scrolling. Is overridden in Ember.ListView.\n\n    @method scrollTo\n  */\n  scrollTo: function(y) {\n    throw new Error('must override to perform the visual scroll and effectively delegate to _scrollContentTo');\n  },\n\n  /**\n    @private\n\n    Internal method used to force scroll position\n\n    @method scrollTo\n  */\n  _scrollTo: Ember.K,\n\n  /**\n    @private\n    @method _scrollContentTo\n  */\n  _scrollContentTo: function(y) {\n    var startingIndex, endingIndex,\n        contentIndex, visibleEndingIndex, maxContentIndex,\n        contentIndexEnd, contentLength, scrollTop;\n\n    scrollTop = max(0, y);\n\n    if (get(this, 'scrollTop') === scrollTop) {\n      return;\n    }\n\n    // allow a visual overscroll, but don't scroll the content. As we are doing needless\n    // recycyling, and adding unexpected nodes to the DOM.\n    scrollTop = Math.min(scrollTop, (get(this, 'totalHeight') - get(this, 'height')));\n\n    Ember.instrument('view._scrollContentTo', {\n      scrollTop: scrollTop,\n      content: get(this, 'content'),\n      startingIndex: this._startingIndex(),\n      endingIndex: min(max(get(this, 'content.length') - 1, 0), this._startingIndex() + this._numChildViewsForViewport())\n    }, function () {\n      contentLength = get(this, 'content.length');\n      set(this, 'scrollTop', scrollTop);\n\n      maxContentIndex = max(contentLength - 1, 0);\n\n      startingIndex = this._startingIndex();\n      visibleEndingIndex = startingIndex + this._numChildViewsForViewport();\n\n      endingIndex = min(maxContentIndex, visibleEndingIndex);\n\n      this.trigger('scrollYChanged', y);\n\n      if (startingIndex === this._lastStartingIndex &&\n          endingIndex === this._lastEndingIndex) {\n        return;\n      }\n\n      this._reuseChildren();\n\n      this._lastStartingIndex = startingIndex;\n      this._lastEndingIndex = endingIndex;\n    }, this);\n  },\n\n  /**\n    @private\n\n    Computes the height for a `Ember.ListView` scrollable container div.\n    You must specify `rowHeight` parameter for the height to be computed properly.\n\n    @property {Ember.ComputedProperty} totalHeight\n  */\n  totalHeight: Ember.computed('content.length', 'rowHeight', 'columnCount', 'bottomPadding', function() {\n    var contentLength, rowHeight, columnCount, bottomPadding;\n\n    contentLength = get(this, 'content.length');\n    rowHeight = get(this, 'rowHeight');\n    columnCount = get(this, 'columnCount');\n    bottomPadding = get(this, 'bottomPadding');\n\n    return ((ceil(contentLength / columnCount)) * rowHeight) + bottomPadding;\n  }),\n\n  /**\n    @private\n    @method _prepareChildForReuse\n  */\n  _prepareChildForReuse: function(childView) {\n    childView.prepareForReuse();\n  },\n\n  /**\n    @private\n    @method _reuseChildForContentIndex\n  */\n  _reuseChildForContentIndex: function(childView, contentIndex) {\n    var content, context, newContext, childsCurrentContentIndex, position, enableProfiling;\n\n    content = get(this, 'content');\n    enableProfiling = get(this, 'enableProfiling');\n    position = this.positionForIndex(contentIndex);\n    set(childView, 'position', position);\n\n    set(childView, 'contentIndex', contentIndex);\n\n    if (enableProfiling) {\n      Ember.instrument('view._reuseChildForContentIndex', position, function(){}, this);\n    }\n\n    newContext = content.objectAt(contentIndex);\n    childView.updateContext(newContext);\n  },\n\n  /**\n    @private\n    @method positionForIndex\n  */\n  positionForIndex: function(index){\n    var elementWidth, width, columnCount, rowHeight, y, x;\n\n    elementWidth = get(this, 'elementWidth') || 1;\n    width = get(this, 'width') || 1;\n    columnCount = get(this, 'columnCount');\n    rowHeight = get(this, 'rowHeight');\n\n    y = (rowHeight * floor(index/columnCount));\n    x = (index % columnCount) * elementWidth;\n\n    return {\n      y: y,\n      x: x\n    };\n  },\n\n  /**\n    @private\n    @method _childViewCount\n  */\n  _childViewCount: function() {\n    var contentLength, childViewCountForHeight;\n\n    contentLength = get(this, 'content.length');\n    childViewCountForHeight = this._numChildViewsForViewport();\n\n    return min(contentLength, childViewCountForHeight);\n  },\n\n  /**\n    @private\n\n    Returns a number of columns in the Ember.ListView (for grid layout).\n\n    If you want to have a multi column layout, you need to specify both\n    `width` and `elementWidth`.\n\n    If no `elementWidth` is specified, it returns `1`. Otherwise, it will\n    try to fit as many columns as possible for a given `width`.\n\n    @property {Ember.ComputedProperty} columnCount\n  */\n  columnCount: Ember.computed('width', 'elementWidth', function() {\n    var elementWidth, width, count;\n\n    elementWidth = get(this, 'elementWidth');\n    width = get(this, 'width');\n\n    if (elementWidth) {\n      count = floor(width / elementWidth);\n    } else {\n      count = 1;\n    }\n\n    return count;\n  }),\n\n  /**\n    @private\n\n    Fires every time column count is changed.\n\n    @event columnCountDidChange\n  */\n  columnCountDidChange: Ember.observer(function(){\n    var ratio, currentScrollTop, proposedScrollTop, maxScrollTop,\n        scrollTop, lastColumnCount, newColumnCount, element;\n\n    lastColumnCount = this._lastColumnCount;\n\n    currentScrollTop = get(this, 'scrollTop');\n    newColumnCount = get(this, 'columnCount');\n    maxScrollTop = get(this, 'maxScrollTop');\n    element = get(this, 'element');\n\n    this._lastColumnCount = newColumnCount;\n\n    if (lastColumnCount) {\n      ratio = (lastColumnCount / newColumnCount);\n      proposedScrollTop = currentScrollTop * ratio;\n      scrollTop = min(maxScrollTop, proposedScrollTop);\n\n      this._scrollTo(scrollTop);\n      set(this, 'scrollTop', scrollTop);\n    }\n\n    if (arguments.length > 0) {\n      // invoked by observer\n      Ember.run.schedule('afterRender', this, syncListContainerWidth);\n    }\n  }, 'columnCount'),\n\n  /**\n    @private\n\n    Computes max possible scrollTop value given the visible viewport\n    and scrollable container div height.\n\n    @property {Ember.ComputedProperty} maxScrollTop\n  */\n  maxScrollTop: Ember.computed('height', 'totalHeight', function(){\n    var totalHeight, viewportHeight;\n\n    totalHeight = get(this, 'totalHeight');\n    viewportHeight = get(this, 'height');\n\n    return max(0, totalHeight - viewportHeight);\n  }),\n\n  /**\n    @private\n\n    Computes the number of views that would fit in the viewport area.\n    You must specify `height` and `rowHeight` parameters for the number of\n    views to be computed properly.\n\n    @method _numChildViewsForViewport\n  */\n  _numChildViewsForViewport: function() {\n    var height, rowHeight, paddingCount, columnCount;\n\n    height = get(this, 'height');\n    rowHeight = get(this, 'rowHeight');\n    paddingCount = get(this, 'paddingCount');\n    columnCount = get(this, 'columnCount');\n\n    return (ceil(height / rowHeight) * columnCount) + (paddingCount * columnCount);\n  },\n\n  /**\n    @private\n\n    Computes the starting index of the item views array.\n    Takes `scrollTop` property of the element into account.\n\n    Is used in `_syncChildViews`.\n\n    @method _startingIndex\n  */\n  _startingIndex: function() {\n    var scrollTop, rowHeight, columnCount, calculatedStartingIndex,\n        contentLength, largestStartingIndex;\n\n    contentLength = get(this, 'content.length');\n    scrollTop = get(this, 'scrollTop');\n    rowHeight = get(this, 'rowHeight');\n    columnCount = get(this, 'columnCount');\n\n    calculatedStartingIndex = floor(scrollTop / rowHeight) * columnCount;\n\n    largestStartingIndex = max(contentLength - 1, 0);\n\n    return min(calculatedStartingIndex, largestStartingIndex);\n  },\n\n  /**\n    @private\n    @event contentWillChange\n  */\n  contentWillChange: Ember.beforeObserver(function() {\n    var content;\n\n    content = get(this, 'content');\n\n    if (content) {\n      content.removeArrayObserver(this);\n    }\n  }, 'content'),\n\n  /**),\n    @private\n    @event contentDidChange\n  */\n  contentDidChange: Ember.observer(function() {\n    addContentArrayObserver.call(this);\n    syncChildViews.call(this);\n  }, 'content'),\n\n  /**\n    @private\n    @property {Function} needsSyncChildViews\n  */\n  needsSyncChildViews: Ember.observer(syncChildViews, 'height', 'width', 'columnCount'),\n\n  /**\n    @private\n\n    Returns a new item view. Takes `contentIndex` to set the context\n    of the returned view properly.\n\n    @param {Number} contentIndex item index in the content array\n    @method _addItemView\n  */\n  _addItemView: function(contentIndex){\n    var itemViewClass, childView;\n\n    itemViewClass = get(this, 'itemViewClass');\n    childView = this.createChildView(itemViewClass);\n\n    this.pushObject(childView);\n   },\n\n  /**\n    @private\n\n    Intelligently manages the number of childviews.\n\n    @method _syncChildViews\n   **/\n  _syncChildViews: function(){\n    var itemViewClass, startingIndex, childViewCount,\n        endingIndex, numberOfChildViews, numberOfChildViewsNeeded,\n        childViews, count, delta, index, childViewsLength, contentIndex;\n\n    if (get(this, 'isDestroyed') || get(this, 'isDestroying')) {\n      return;\n    }\n\n    childViewCount = this._childViewCount();\n    childViews = this.positionOrderedChildViews();\n\n    startingIndex = this._startingIndex();\n    endingIndex = startingIndex + childViewCount;\n\n    numberOfChildViewsNeeded = childViewCount;\n    numberOfChildViews = childViews.length;\n\n    delta = numberOfChildViewsNeeded - numberOfChildViews;\n\n    if (delta === 0) {\n      // no change\n    } else if (delta > 0) {\n      // more views are needed\n      contentIndex = this._lastEndingIndex;\n\n      for (count = 0; count < delta; count++, contentIndex++) {\n        this._addItemView(contentIndex);\n      }\n\n    } else {\n      // less views are needed\n      forEach.call(\n        childViews.splice(numberOfChildViewsNeeded, numberOfChildViews),\n        removeAndDestroy,\n        this\n      );\n    }\n\n    this._reuseChildren();\n\n    this._lastStartingIndex = startingIndex;\n    this._lastEndingIndex   = this._lastEndingIndex + delta;\n  },\n\n  /**\n    @private\n    @method _reuseChildren\n  */\n  _reuseChildren: function(){\n    var contentLength, childViews, childViewsLength,\n        startingIndex, endingIndex, childView, attrs,\n        contentIndex, visibleEndingIndex, maxContentIndex,\n        contentIndexEnd, scrollTop;\n\n    scrollTop = get(this, 'scrollTop');\n    contentLength = get(this, 'content.length');\n    maxContentIndex = max(contentLength - 1, 0);\n    childViews = this.getReusableChildViews();\n    childViewsLength =  childViews.length;\n\n    startingIndex = this._startingIndex();\n    visibleEndingIndex = startingIndex + this._numChildViewsForViewport();\n\n    endingIndex = min(maxContentIndex, visibleEndingIndex);\n\n    contentIndexEnd = min(visibleEndingIndex, startingIndex + childViewsLength);\n\n    for (contentIndex = startingIndex; contentIndex < contentIndexEnd; contentIndex++) {\n      childView = childViews[contentIndex % childViewsLength];\n      this._reuseChildForContentIndex(childView, contentIndex);\n    }\n  },\n\n  /**\n    @private\n    @method getReusableChildViews\n  */\n  getReusableChildViews: function() {\n    return this._childViews;\n  },\n\n  /**\n    @private\n    @method positionOrderedChildViews\n  */\n  positionOrderedChildViews: function() {\n    return this.getReusableChildViews().sort(sortByContentIndex);\n  },\n\n  arrayWillChange: Ember.K,\n\n  /**\n    @private\n    @event arrayDidChange\n  */\n  // TODO: refactor\n  arrayDidChange: function(content, start, removedCount, addedCount) {\n    var index, contentIndex;\n\n    if (this.state === 'inDOM') {\n      // ignore if all changes are out of the visible change\n      if( start >= this._lastStartingIndex || start < this._lastEndingIndex) {\n        index = 0;\n        // ignore all changes not in the visible range\n        // this can re-position many, rather then causing a cascade of re-renders\n        forEach.call(\n          this.positionOrderedChildViews(),\n          function(childView) {\n            contentIndex = this._lastStartingIndex + index;\n            this._reuseChildForContentIndex(childView, contentIndex);\n            index++;\n          },\n          this\n        );\n      }\n\n      syncChildViews.call(this);\n    }\n  }\n});\n\n})();\n//@ sourceURL=list-view/list_view_mixin");minispade.register('list-view', "(function() {minispade.require(\"list-view/list_item_view\");\nminispade.require(\"list-view/reusable_list_item_view\");\nminispade.require(\"list-view/list_view\");\nminispade.require(\"list-view/virtual_list_view\");\n\n})();\n//@ sourceURL=list-view");minispade.register('list-view/reusable_list_item_view', "(function() {minispade.require('list-view/list_item_view_mixin');\n\nvar get = Ember.get, set = Ember.set;\n\nEmber.ReusableListItemView = Ember.View.extend(Ember.ListItemViewMixin, {\n  init: function(){\n    this._super();\n    this.set('context', Ember.ObjectProxy.create());\n  },\n  isVisible: Ember.computed('context.content', function(){\n    return !!this.get('context.content');\n  }),\n  updateContext: function(newContext){\n    var context = get(this, 'context.content');\n    if (context !== newContext) {\n      if (this.state === 'inDOM') {\n        this.prepareForReuse(newContext);\n      }\n      set(this, 'context.content', newContext);\n    }\n  },\n  prepareForReuse: Ember.K\n});\n\n})();\n//@ sourceURL=list-view/reusable_list_item_view");minispade.register('list-view/virtual_list_scroller_events', "(function() {var fieldRegex = /input|textarea|select/i,\n  hasTouch = ('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch,\n  handleStart, handleMove, handleEnd, handleCancel,\n  startEvent, moveEvent, endEvent, cancelEvent;\nif (hasTouch) {\n  startEvent = 'touchstart';\n  handleStart = function (e) {\n    var touch = e.touches[0],\n      target = touch && touch.target;\n    // avoid e.preventDefault() on fields\n    if (target && fieldRegex.test(target.tagName)) {\n      return;\n    }\n    bindWindow(this.scrollerEventHandlers);\n    this.willBeginScroll(e.touches, e.timeStamp);\n    e.preventDefault();\n  };\n  moveEvent = 'touchmove';\n  handleMove = function (e) {\n    this.continueScroll(e.touches, e.timeStamp);\n  };\n  endEvent = 'touchend';\n  handleEnd = function (e) {\n    // if we didn't end up scrolling we need to\n    // synthesize click since we did e.preventDefault()\n    // on touchstart\n    if (!this._isScrolling) {\n      synthesizeClick(e);\n    }\n    unbindWindow(this.scrollerEventHandlers);\n    this.endScroll(e.timeStamp);\n  };\n  cancelEvent = 'touchcancel';\n  handleCancel = function (e) {\n    unbindWindow(this.scrollerEventHandlers);\n    this.endScroll(e.timeStamp);\n  };\n} else {\n  startEvent = 'mousedown';\n  handleStart = function (e) {\n    if (e.which !== 1) return;\n    var target = e.target;\n    // avoid e.preventDefault() on fields\n    if (target && fieldRegex.test(target.tagName)) {\n      return;\n    }\n    bindWindow(this.scrollerEventHandlers);\n    this.willBeginScroll([e], e.timeStamp);\n    e.preventDefault();\n  };\n  moveEvent = 'mousemove';\n  handleMove = function (e) {\n    this.continueScroll([e], e.timeStamp);\n  };\n  endEvent = 'mouseup';\n  handleEnd = function (e) {\n    unbindWindow(this.scrollerEventHandlers);\n    this.endScroll(e.timeStamp);\n  };\n  cancelEvent = 'mouseout';\n  handleCancel = function (e) {\n    if (e.relatedTarget) return;\n    unbindWindow(this.scrollerEventHandlers);\n    this.endScroll(e.timeStamp);\n  };\n}\n\nfunction handleWheel(e) {\n  this.mouseWheel(e);\n  e.preventDefault();\n}\n\nfunction bindElement(el, handlers) {\n  el.addEventListener(startEvent, handlers.start, false);\n  el.addEventListener('mousewheel', handlers.wheel, false);\n}\n\nfunction unbindElement(el, handlers) {\n  el.removeEventListener(startEvent, handlers.start, false);\n  el.removeEventListener('mousewheel', handlers.wheel, false);\n}\n\nfunction bindWindow(handlers) {\n  window.addEventListener(moveEvent, handlers.move, true);\n  window.addEventListener(endEvent, handlers.end, true);\n  window.addEventListener(cancelEvent, handlers.cancel, true);\n}\n\nfunction unbindWindow(handlers) {\n  window.removeEventListener(moveEvent, handlers.move, true);\n  window.removeEventListener(endEvent, handlers.end, true);\n  window.removeEventListener(cancelEvent, handlers.cancel, true);\n}\n\nEmber.VirtualListScrollerEvents = Ember.Mixin.create({\n  init: function() {\n    this.on('didInsertElement', this, 'bindScrollerEvents');\n    this.on('willDestroyElement', this, 'unbindScrollerEvents');\n    this.scrollerEventHandlers = {\n      start: bind(this, handleStart),\n      move: bind(this, handleMove),\n      end: bind(this, handleEnd),\n      cancel: bind(this, handleCancel),\n      wheel: bind(this, handleWheel)\n    };\n    return this._super();\n  },\n  bindScrollerEvents: function() {\n    var el = this.get('element'),\n      handlers = this.scrollerEventHandlers;\n    bindElement(el, handlers);\n  },\n  unbindScrollerEvents: function() {\n    var el = this.get('element'),\n      handlers = this.scrollerEventHandlers;\n    unbindElement(el, handlers);\n    unbindWindow(handlers);\n  }\n});\n\nfunction bind(view, handler) {\n  return function (evt) {\n    handler.call(view, evt);\n  };\n}\n\nfunction synthesizeClick(e) {\n  var point = e.changedTouches[0],\n    target = point.target,\n    ev;\n  if (target && fieldRegex.test(target.tagName)) {\n    ev = document.createEvent('MouseEvents');\n    ev.initMouseEvent('click', true, true, e.view, 1, point.screenX, point.screenY, point.clientX, point.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);\n    return target.dispatchEvent(ev);\n  }\n}\n\n})();\n//@ sourceURL=list-view/virtual_list_scroller_events");minispade.register('list-view/virtual_list_view', "(function() {/*global Scroller*/\nminispade.require('list-view/list_view_mixin');\nminispade.require('list-view/list_view_helper');\nminispade.require('list-view/virtual_list_scroller_events');\n\nvar max = Math.max, get = Ember.get, set = Ember.set;\n\nfunction updateScrollerDimensions(target) {\n  var width, height, totalHeight;\n\n  target = target || this;\n\n  width = get(target, 'width');\n  height = get(target, 'height');\n  totalHeight = get(target, 'totalHeight');\n\n  target.scroller.setDimensions(width, height, width, totalHeight);\n  target.trigger('scrollerDimensionsDidChange');\n}\n\n/**\n  VirtualListView\n\n  @class VirtualListView\n  @namespace Ember\n*/\nEmber.VirtualListView = Ember.ContainerView.extend(Ember.ListViewMixin, Ember.VirtualListScrollerEvents, {\n  _isScrolling: false,\n  _mouseWheel: null,\n  css: {\n    position: 'relative',\n    overflow: 'hidden'\n  },\n\n  init: function(){\n    this._super();\n    this.setupScroller();\n    this.setupPullToRefresh();\n  },\n  _scrollerTop: 0,\n  applyTransform: Ember.ListViewHelper.apply3DTransform,\n\n  setupScroller: function(){\n    var view, y;\n\n    view = this;\n\n    view.scroller = new Scroller(function(left, top, zoom) {\n      if (view.state !== 'inDOM') { return; }\n\n      if (view.listContainerElement) {\n        view.applyTransform(view.listContainerElement, 0, -top);\n        view._scrollerTop = top;\n        view._scrollContentTo(top);\n      }\n    }, {\n      scrollingX: false,\n      scrollingComplete: function(){\n        view.trigger('scrollingDidComplete');\n      }\n    });\n\n    view.trigger('didInitializeScroller');\n    updateScrollerDimensions(view);\n  },\n  setupPullToRefresh: function() {\n    if (!this.pullToRefreshViewClass) { return; }\n    this._insertPullToRefreshView();\n    this._activateScrollerPullToRefresh();\n  },\n  _insertPullToRefreshView: function(){\n    this.pullToRefreshView = this.createChildView(this.pullToRefreshViewClass);\n    this.insertAt(0, this.pullToRefreshView);\n    var view = this;\n    this.pullToRefreshView.on('didInsertElement', function(){\n      view.applyTransform(this.get('element'), 0, -1 * view.pullToRefreshViewHeight);\n    });\n  },\n  _activateScrollerPullToRefresh: function(){\n    var view = this;\n    function activatePullToRefresh(){\n      view.pullToRefreshView.set('active', true);\n      view.trigger('activatePullToRefresh');\n    }\n    function deactivatePullToRefresh() {\n      view.pullToRefreshView.set('active', false);\n      view.trigger('deactivatePullToRefresh');\n    }\n    function startPullToRefresh() {\n      view.pullToRefreshView.set('refreshing', true);\n\n      function finishRefresh(){\n        if (view && !view.get('isDestroyed') && !view.get('isDestroying')) {\n          view.scroller.finishPullToRefresh();\n          view.pullToRefreshView.set('refreshing', false);\n        }\n      }\n      view.startRefresh(finishRefresh);\n    }\n    this.scroller.activatePullToRefresh(\n      this.pullToRefreshViewHeight,\n      activatePullToRefresh,\n      deactivatePullToRefresh,\n      startPullToRefresh\n    );\n  },\n\n  getReusableChildViews: function(){\n    var firstView = this._childViews[0];\n    if (firstView && firstView === this.pullToRefreshView) {\n      return this._childViews.slice(1);\n    } else {\n      return this._childViews;\n    }\n  },\n\n  scrollerDimensionsNeedToChange: Ember.observer(function() {\n    Ember.run.once(this, updateScrollerDimensions);\n  }, 'width', 'height', 'totalHeight'),\n\n  didInsertElement: function() {\n    this.listContainerElement = this.$('> .ember-list-container')[0];\n  },\n\n  willBeginScroll: function(touches, timeStamp) {\n    this._isScrolling = false;\n    this.trigger('scrollingDidStart');\n\n    this.scroller.doTouchStart(touches, timeStamp);\n  },\n\n  continueScroll: function(touches, timeStamp) {\n    var startingScrollTop, endingScrollTop, event;\n\n    if (this._isScrolling) {\n      this.scroller.doTouchMove(touches, timeStamp);\n    } else {\n      startingScrollTop = this._scrollerTop;\n\n      this.scroller.doTouchMove(touches, timeStamp);\n\n      endingScrollTop = this._scrollerTop;\n\n      if (startingScrollTop !== endingScrollTop) {\n        event = Ember.$.Event(\"scrollerstart\");\n        Ember.$(touches[0].target).trigger(event);\n\n        this._isScrolling = true;\n      }\n    }\n  },\n\n  endScroll: function(timeStamp) {\n    this.scroller.doTouchEnd(timeStamp);\n  },\n\n  // api\n  scrollTo: function(y, animate) {\n    if (animate === undefined) {\n      animate = true;\n    }\n\n    this.scroller.scrollTo(0, y, animate, 1);\n  },\n\n  // events\n  mouseWheel: function(e){\n    var inverted, delta, candidatePosition;\n\n    inverted = e.webkitDirectionInvertedFromDevice;\n    delta = e.wheelDeltaY * (inverted ? 0.8 : -0.8);\n    candidatePosition = this.scroller.__scrollTop + delta;\n\n    if ((candidatePosition >= 0) && (candidatePosition <= this.scroller.__maxScrollTop)) {\n      this.scroller.scrollBy(0, delta, true);\n    }\n\n    return false;\n  }\n});\n\n})();\n//@ sourceURL=list-view/virtual_list_view");